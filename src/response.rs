use std::str::FromStr;

use thiserror::Error;
use tokio::io::{AsyncBufRead, Lines};

// TODO(jsvana): handle multiline in a sane way,
// maybe in a wrapper struct?
#[derive(Debug)]
pub enum Response {
    /// Response code 100 (multi-line)
    ///    Generated by: HELP
    ///    Meaning: help text follows.
    HelpFollows(i32),

    /// Response code 101 (multi-line)
    ///   Generated by: CAPABILITIES
    ///   Meaning: capabilities list follows.
    CapabilitiesFollow {
        code: i32,
        rest: Option<String>,
    },

    /// Response code 111
    ///    Generated by: DATE
    ///    1 argument: yyyymmddhhmmss
    ///    Meaning: server date and time.
    Date { code: i32, date: String },

    /// Response code 200
    ///    Generated by: initial connection, MODE READER
    ///    Meaning: service available, posting allowed.
    ServiceAvailablePostingAllowed { code: i32, rest: Option<String> },

    /// Response code 201
    ///    Generated by: initial connection, MODE READER
    ///    Meaning: service available, posting prohibited.
    ServiceAvailablePostingForbidden(i32),

    /// Response code 205
    ///    Generated by: QUIT
    ///    Meaning: connection closing (the server immediately closes the
    ///    connection).
    Quit {
        code: i32,
        rest: Option<String>,
    },

    /// Response code 211
    ///    The 211 response code has two completely different forms,
    ///    depending on which command generated it:
    ///       (not multi-line)
    ///       Generated by: GROUP
    ///       4 arguments: number low high group
    ///       Meaning: group selected.
    GroupSelected {
        code: i32,
        number: i32,
        low: i32,
        high: i32,
        group: String,
    },

    /// Response code 211
    ///    The 211 response code has two completely different forms,
    ///    depending on which command generated it:
    ///       (multi-line)
    ///       Generated by: LISTGROUP
    ///       4 arguments: number low high group
    ///       Meaning: article numbers follow.
    ListGroup {
        code: i32,
        number: i32,
        low: i32,
        high: i32,
        group: String,
    },

    /// Response code 215 (multi-line)
    ///    Generated by: LIST
    ///    Meaning: information follows.
    InformationFollows { code: i32, rest: Option<String> },

    /// Response code 220 (multi-line)
    ///    Generated by: ARTICLE
    ///    2 arguments: n message-id
    ///    Meaning: article follows.
    ArticleFollows {
        code: i32,
        number: i32,
        message_id: String,
    },

    /// Response code 221 (multi-line)
    ///    Generated by: HEAD
    ///    2 arguments: n message-id
    ///    Meaning: article headers follow.
    ArticleHeadersFollow {
        code: i32,
        number: i32,
        message_id: String,
    },

    /// Response code 222 (multi-line)
    ///    Generated by: BODY
    ///    2 arguments: n message-id
    ///    Meaning: article body follows.
    ArticleBodyFollows {
        code: i32,
        number: i32,
        message_id: String,
    },

    /// Response code 223
    ///    Generated by: LAST, NEXT, STAT
    ///    2 arguments: n message-id
    ///    Meaning: article exists and selected.
    ArticleSelected {
        code: i32,
        number: i32,
        message_id: String,
    },

    /// Response code 224 (multi-line)
    ///    Generated by: OVER
    ///    Meaning: overview information follows.
    OverviewFollows(i32),

    /// Response code 225 (multi-line)
    ///    Generated by: HDR
    ///    Meaning: headers follow.
    HeadersFollow(i32),

    /// Response code 230 (multi-line)
    ///    Generated by: NEWNEWS
    ///    Meaning: list of new articles follows.
    NewArticlesFollow(i32),

    /// Response code 231 (multi-line)
    ///    Generated by: NEWGROUPS
    ///    Meaning: list of new newsgroups follows.
    NewNewsgroupsFollow(i32),

    /// Response code 235
    ///    Generated by: IHAVE (second stage)
    ///    Meaning: article transferred OK.
    ArticleTransferred(i32),

    /// Response code 240
    ///    Generated by: POST (second stage)
    ///    Meaning: article received OK.
    ArticleReceived(i32),

    /// Response code 335
    ///    Generated by: IHAVE (first stage)
    ///    Meaning: send article to be transferred.
    ReadyForArticleTransfer(i32),

    /// Response code 340
    ///    Generated by: POST (first stage)
    ///    Meaning: send article to be posted.
    ReadyForArticlePost(i32),

    /// Response code 400
    ///    Generic response and generated by initial connection
    ///    Meaning: service not available or no longer available (the server
    ///    immediately closes the connection).
    Unavailable(i32),

    /// Response code 401
    ///    Generic response
    ///    1 argument: capability-label
    ///    Meaning: the server is in the wrong mode; the indicated capability
    ///    should be used to change the mode.
    IncorrectMode { code: i32, capability_label: String },

    /// Response code 403
    ///    Generic response
    ///    Meaning: internal fault or problem preventing action being taken.
    InternalError(i32),

    /// Response code 411
    ///    Generated by: GROUP, LISTGROUP
    ///    Meaning: no such newsgroup.
    NoSuchNewsgroup(i32),

    /// Response code 412
    ///    Generated by: ARTICLE, BODY, GROUP, HDR, HEAD, LAST, LISTGROUP,
    ///    NEXT, OVER, STAT
    ///    Meaning: no newsgroup selected.
    NoNewsgroupSelected(i32),

    /// Response code 420
    ///    Generated by: ARTICLE, BODY, HDR, HEAD, LAST, NEXT, OVER, STAT
    ///    Meaning: current article number is invalid.
    InvalidArticleNumber(i32),

    /// Response code 421
    ///    Generated by: NEXT
    ///    Meaning: no next article in this group.
    NoNextArticle(i32),

    /// Response code 422
    ///    Generated by: LAST
    ///    Meaning: no previous article in this group.
    NoPreviousArticle(i32),

    /// Response code 423
    ///    Generated by: ARTICLE, BODY, HDR, HEAD, OVER, STAT
    ///    Meaning: no article with that number or in that range.
    NoSuchArticleByNumber(i32),

    /// Response code 430
    ///    Generated by: ARTICLE, BODY, HDR, HEAD, OVER, STAT
    ///    Meaning: no article with that message-id.
    NoSuchArticleByMessageId(i32),

    /// Response code 435
    ///    Generated by: IHAVE (first stage)
    ///    Meaning: article not wanted.
    ArticleNotWanted(i32),

    /// Response code 436
    ///    Generated by: IHAVE (either stage)
    ///    Meaning: transfer not possible (first stage) or failed (second
    ///    stage); try again later.
    ArticleTransferFailedCanRetry(i32),

    /// Response code 437
    ///    Generated by: IHAVE (second stage)
    ///    Meaning: transfer rejected; do not retry.
    ArticleTransferFailedNoRetry(i32),

    /// Response code 440
    ///    Generated by: POST (first stage)
    ///    Meaning: posting not permitted.
    PostingNotPermitted(i32),

    /// Response code 441
    ///    Generated by: POST (second stage)
    ///    Meaning: posting failed.
    PostingFailed(i32),

    /// Response code 480
    ///    Generic response
    ///    Meaning: command unavailable until the client has authenticated
    ///    itself.
    CommandUnavaibleNeedAuthentication(i32),

    /// Response code 483
    ///    Generic response
    ///    Meaning: command unavailable until suitable privacy has been
    ///    arranged.
    CommandUnavaibleNeedPrivacy(i32),

    /// Response code 500
    ///    Generic response
    ///    Meaning: unknown command.
    UnknownCommand(i32),

    /// Response code 501
    ///    Generic response
    ///    Meaning: syntax error in command.
    CommandSyntaxError(i32),

    /// Response code 502
    ///    Generic response and generated by initial connection
    ///
    ///    Meaning for the initial connection and the MODE READER command:
    ///    service permanently unavailable (the server immediately closes the
    ///    connection).
    ///
    ///    Meaning for all other commands: command not permitted (and there
    ///    is no way for the client to change this).
    CommandNotPermitted(i32),

    /// Response code 503
    ///    Generic response
    ///    Meaning: feature not supported.
    FeatureNotSupported(i32),

    /// Response code 504
    ///    Generic response
    ///    Meaning: error in base64-encoding [RFC4648] of an argument.
    Base64EncodingError(i32),
}

#[derive(Debug, Error)]
pub enum ParseResponseError {
    #[error("given line is empty")]
    EmptyLine,
    #[error("invalid non-integer response code \"{code}\", line \"{line}\"")]
    NonIntegerResponseCode { code: String, line: String },
    #[error("unknown response code \"{code}\", line \"{line}\"")]
    UnknownResponseCode { code: i32, line: String },
}

impl FromStr for Response {
    type Err = ParseResponseError;

    fn from_str(line: &str) -> Result<Self, Self::Err> {
        if line.is_empty() {
            return Err(ParseResponseError::EmptyLine);
        }

        match line.find(char::is_whitespace) {
            Some(index) => match &line[..index].parse::<i32>() {
                Ok(code) => match code {
                    101 => Ok(Response::CapabilitiesFollow {
                        code: *code,
                        rest: Some(line[index + 1..].to_string()),
                    }),
                    200 => Ok(Response::ServiceAvailablePostingAllowed {
                        code: *code,
                        rest: Some(line[index + 1..].to_string()),
                    }),
                    205 => Ok(Response::Quit {
                        code: *code,
                        rest: Some(line[index + 1..].to_string()),
                    }),
                    215 => Ok(Response::InformationFollows {
                        code: *code,
                        rest: Some(line[index + 1..].to_string()),
                    }),
                    _ => Err(ParseResponseError::UnknownResponseCode {
                        code: *code,
                        line: line.to_string(),
                    }),
                },
                Err(_) => Err(ParseResponseError::NonIntegerResponseCode {
                    code: line[..index].to_string(),
                    line: line.to_string(),
                }),
            },
            None => match line.parse::<i32>() {
                Ok(code) => match code {
                    101 => Ok(Response::CapabilitiesFollow {
                        code,
                        rest: None,
                    }),
                    200 => Ok(Response::ServiceAvailablePostingAllowed { code, rest: None }),
                    205 => Ok(Response::Quit {
                        code,
                        rest: None,
                    }),
                    215 => Ok(Response::InformationFollows { code, rest: None }),
                    _ => Err(ParseResponseError::UnknownResponseCode {
                        code,
                        line: line.to_string(),
                    }),
                },
                Err(_) => Err(ParseResponseError::NonIntegerResponseCode {
                    code: line.to_string(),
                    line: line.to_string(),
                }),
            },
        }
    }
}

#[derive(Debug)]
pub enum NewsgroupStatus {
    PostingPermitted,
    PostingNotPermitted,
    PostingModerated,
}

#[derive(Debug, Error)]
pub enum ParseNewsgroupStatusError {
    #[error("given line is empty")]
    EmptyLine,
    #[error("unknown newsgroup status \"{0}\"")]
    UnknownStatus(String),
}

impl FromStr for NewsgroupStatus {
    type Err = ParseNewsgroupStatusError;

    fn from_str(line: &str) -> Result<Self, Self::Err> {
        match line {
            "y" => Ok(NewsgroupStatus::PostingPermitted),
            "n" => Ok(NewsgroupStatus::PostingNotPermitted),
            "m" => Ok(NewsgroupStatus::PostingModerated),
            "" => Err(ParseNewsgroupStatusError::EmptyLine),
            _ => Err(ParseNewsgroupStatusError::UnknownStatus(line.to_string())),
        }
    }
}

#[derive(Debug)]
pub struct NewsgroupInfo {
    pub name: String,
    pub high: u32,
    pub low: u32,
    pub status: NewsgroupStatus,
}

#[derive(Debug, Error)]
pub enum ParseNewsgroupInfoError {
    #[error("given line is empty")]
    EmptyLine,
    #[error("invalid number of fields (expected 4, got {field_count}) for line \"{line}\"")]
    InvalidFieldCount { field_count: usize, line: String },
    #[error("line \"{0}\" missing name field")]
    MissingName(String),
    #[error("line \"{0}\" missing low field")]
    MissingLow(String),
    #[error("line has invalid low value \"{0}\"")]
    InvalidLowValue(String),
    #[error("line \"{0}\" missing high field")]
    MissingHigh(String),
    #[error("line has invalid high value \"{0}\"")]
    InvalidHighValue(String),
    #[error("line \"{0}\" missing status field")]
    MissingStatus(String),
    #[error(transparent)]
    InvalidStatus(#[from] ParseNewsgroupStatusError),
}

impl FromStr for NewsgroupInfo {
    type Err = ParseNewsgroupInfoError;

    fn from_str(line: &str) -> Result<Self, Self::Err> {
        let parts: Vec<&str> = line.split_whitespace().collect();

        if parts.len() != 4 {
            return Err(ParseNewsgroupInfoError::InvalidFieldCount {
                field_count: parts.len(),
                line: line.to_string(),
            });
        }

        let name = parts
            .get(0)
            .ok_or_else(|| ParseNewsgroupInfoError::MissingName(line.to_string()))?;
        let high = parts
            .get(1)
            .ok_or_else(|| ParseNewsgroupInfoError::MissingHigh(line.to_string()))?;
        let high: u32 = high
            .parse()
            .map_err(|_| ParseNewsgroupInfoError::InvalidHighValue(high.to_string()))?;
        let low = parts
            .get(2)
            .ok_or_else(|| ParseNewsgroupInfoError::MissingLow(line.to_string()))?;
        let low: u32 = low
            .parse()
            .map_err(|_| ParseNewsgroupInfoError::InvalidLowValue(low.to_string()))?;
        let status = parts
            .get(3)
            .ok_or_else(|| ParseNewsgroupInfoError::MissingStatus(line.to_string()))?;
        let status: NewsgroupStatus = status.parse()?;

        Ok(NewsgroupInfo {
            name: name.to_string(),
            high,
            low,
            status,
        })
    }
}

#[derive(Debug)]
pub struct Capability {
    pub name: String,
    pub params: Vec<String>,
}

#[derive(Debug, Error)]
pub enum ParseCapabilityError {
    #[error("given line is empty")]
    EmptyLine,
}

impl FromStr for Capability {
    type Err = ParseCapabilityError;

    fn from_str(line: &str) -> Result<Self, Self::Err> {
        let parts: Vec<&str> = line.split_whitespace().collect();
        let mut parts_iter = parts.into_iter();

        let name = parts_iter.next().ok_or_else(|| ParseCapabilityError::EmptyLine)?.to_string();
        let params: Vec<String> = parts_iter.map(|s| s.to_string()).collect();

        Ok(Capability {
            name,
            params,
        })
    }
}

pub enum ListParseState {
    Parsing,
    Complete,
}

#[derive(Debug, Error)]
pub enum ParseListError {
    #[error(transparent)]
    IoError(#[from] std::io::Error),
    #[error("invalid item \"{line}\": {error}")]
    InvalidItem {
        line: String,
        error: String,
    },
    #[error("newsgroup list never terminated")]
    UnfinishedNewsgroupList,
}

pub async fn parse_list<T, U>(lines: &mut Lines<T>) -> Result<Vec<U>, ParseListError>
    where
    T: AsyncBufRead + Unpin, U: FromStr, <U as std::str::FromStr>::Err: std::fmt::Display {
    let mut items = Vec::new();
    let mut state = ListParseState::Parsing;

    while let Some(line) = lines.next_line().await? {
        match &line[..] {
            "." => {
                state = ListParseState::Complete;
                break;
            }
            _ => {
                match line.parse::<U>() {
                    Ok(item) => items.push(item),
                    Err(e) => {
                        return Err(ParseListError::InvalidItem { line, error: e.to_string() });
                    }
                }
            }
        }
    }

    match state {
        ListParseState::Parsing => {
            Err(ParseListError::UnfinishedNewsgroupList)
        }
        ListParseState::Complete => {
            Ok(items)
        }
    }
}
